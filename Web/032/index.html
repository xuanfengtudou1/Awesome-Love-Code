<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2025 → 2026 新年快乐！</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
            font-family: 'Arial', sans-serif; /* Fallback for fonts */
            touch-action: manipulation; /* Prevent default browser touch actions */
            -webkit-user-select: none; /* Disable text selection on iOS */
            -moz-user-select: none; /* Disable text selection on Firefox */
            -ms-user-select: none; /* Disable text selection on IE/Edge */
            user-select: none; /* Disable text selection */
        }
        canvas {
            display: block;
            background-color: black; /* 初始背景色 */
        }
        /* 可选的预加载字体，确保中文字符显示 */
        @font-face {
            font-family: 'HappyNewYearFont';
            src: url('simhei.ttf') format('truetype'); /* 如果simhei.ttf放在同目录下，可以尝试加载 */
            /* 如果simhei.ttf不在同目录下，或者加载失败，会使用系统默认字体 */
            font-weight: normal;
            font-style: normal;
        }
    </style>
</head>
<body>
    <canvas id="fireworksCanvas"></canvas>

    <script>
        const canvas = document.getElementById('fireworksCanvas');
        const ctx = canvas.getContext('2d');

        // 设置 Canvas 为全屏
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 颜色定义
        const BLACK = { r: 0, g: 0, b: 0 };
        const RED = { r: 180, g: 0, b: 0 };
        const GOLD = { r: 255, g: 215, b: 0 };
        const WHITE = { r: 255, g: 255, b: 255 };

        // 粒子类 (JavaScript 版本)
        class Particle {
            constructor(x, y, color, speed = null) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const radius = speed === null ? Math.random() * 6 + 2 : speed;
                this.vx = Math.cos(angle) * radius;
                this.vy = Math.sin(angle) * radius;
                this.life = 255; // 0-255 透明度
                this.gravity = 0.12;
            }

            update() {
                this.vx *= 0.96;
                this.vy *= 0.96;
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 5;
            }

            draw() {
                if (this.life > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.life / 255;
                    ctx.fillStyle = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
                    const size = Math.max(1, Math.floor(this.life / 60));
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        let particles = [];
        let stage = 2025; // 2025 -> 2026 -> "HAPPY"
        let currentBgColor = { r: BLACK.r, g: BLACK.g, b: BLACK.b };
        let textAlpha = 255;
        let isTransitioning = false;
        let lastYearChangeTime = 0; // 用于控制2026阶段自动跳转

        // 字体配置
        const getFont = (size) => {
            // 尝试使用预加载字体，如果失败则使用系统字体
            const baseFont = 'HappyNewYearFont, "SimHei", "Arial", sans-serif'; 
            return `${size}px ${baseFont}`;
        };
        const getYearFontSize = () => canvas.width * 0.15;
        const getWishFontSize = () => canvas.width * 0.12;
        const getHintFontSize = () => canvas.width * 0.03;

        // 绘制文字
        function drawText(text, fontSize, color, alpha, yOffset = 0) {
            ctx.save();
            ctx.globalAlpha = alpha / 255;
            ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
            ctx.font = getFont(fontSize);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2 + yOffset);
            ctx.restore();
        }

        // 主动画循环
        function animate() {
            // 清除画布并设置背景色
            ctx.fillStyle = `rgb(${currentBgColor.r}, ${currentBgColor.g}, ${currentBgColor.b})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 1. 随机烟花逻辑
            const chance = (stage === "HAPPY") ? 0.08 : 0.04;
            if (Math.random() < chance) {
                const colors = [GOLD, WHITE, { r: 255, g: 100, b: 100 }, { r: 255, g: 255, b: 100}];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const rx = Math.random() * (canvas.width * 0.8) + (canvas.width * 0.1);
                const ry = Math.random() * (canvas.height * 0.5) + (canvas.height * 0.1);
                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(rx, ry, color));
                }
            }
            
            // 2. 转场状态机
            if (isTransitioning) {
                textAlpha -= 6;
                if (textAlpha <= 0) {
                    if (stage === 2025) {
                        stage = 2026;
                        textAlpha = 255;
                        isTransitioning = false;
                        lastYearChangeTime = Date.now(); // 记录2026显示时间
                        // 2026 爆发烟花
                        for (let i = 0; i < 150; i++) {
                            particles.push(new Particle(canvas.width / 2, canvas.height / 2, GOLD, Math.random() * 8 + 4));
                        }
                    } else if (stage === 2026) {
                        stage = "HAPPY";
                        textAlpha = 0; // 准备淡入
                        isTransitioning = false;
                    }
                }
            }

            // 3. 自动进入“新年快乐”阶段
            if (stage === 2026 && !isTransitioning && (Date.now() - lastYearChangeTime > 2000)) { // 2026停留约2秒
                isTransitioning = true;
            }

            // 4. 红底背景渐变逻辑
            if (stage === "HAPPY") {
                if (currentBgColor.r < RED.r) currentBgColor.r = Math.min(RED.r, currentBgColor.r + 2);
                if (textAlpha < 255) textAlpha = Math.min(255, textAlpha + 5);
                
                // 持续散落金粉
                if (Math.random() < 0.2) {
                    particles.push(new Particle(Math.random() * canvas.width, 0, GOLD, 2));
                }
            }

            // 渲染文字
            if (stage === 2025 || stage === 2026) {
                const textColor = (stage === 2025) ? WHITE : GOLD;
                drawText(String(stage), getYearFontSize(), textColor, textAlpha);
            } else { // HAPPY
                drawText("新年快乐", getWishFontSize(), GOLD, textAlpha);
                // 英文祝福语
                drawText("Happy New Year!", getHintFontSize() * 1.2, WHITE, textAlpha, canvas.height * 0.1); 
            }
            
            // 提示语
            if (stage === 2025) {
                drawText("点击屏幕 跨越2025", getHintFontSize(), { r: 150, g: 150, b: 150 }, 255, canvas.height * 0.2);
            }

            // 更新并绘制粒子
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if (p.life <= 0) {
                    particles.splice(i, 1); // 移除死亡粒子
                }
            }

            requestAnimationFrame(animate); // 循环动画
        }

        // 监听点击事件触发转场
        canvas.addEventListener('click', () => {
            if (stage === 2025 && !isTransitioning) {
                isTransitioning = true;
            }
        });

        // 启动动画
        animate();

    </script>
</body>
</html>
